package service

import (
	"context"
	"errors"
	"math"
	"strings"
	{{if .ImportTime}}"time"{{end}}
	"github.com/hongshengjie/crud/xsql"
	"{{.RelativePath}}/crud"
	"{{.RelativePath}}/crud/{{.PackageName}}"
	"{{.RelativePath}}/api"
	"google.golang.org/protobuf/types/known/emptypb"

)
{{ $pkgName := .PackageName}}
{{ $tableName := .GoTableName}}

// {{.GoTableName}}ServiceImpl {{.GoTableName}}ServiceImpl
type {{.GoTableName}}ServiceImpl struct {
	Client *crud.Client
}

// Create{{.GoTableName}} Create{{.GoTableName}}
func (s *{{.GoTableName}}ServiceImpl) CreateUser(ctx context.Context, req *api.{{.GoTableName}}) (*api.{{.GoTableName}}, error) {
	
	// do some parameter check
	// if req.GetXXXX() != 0 {
	// 	return nil, errors.New(-1, "参数错误")
	// }
	a := &{{.PackageName}}.{{.GoTableName}}{
		{{- range $index,$field := .Fields }}
			{{- if ne .GoColumnType  "time.Time"}}
				{{- if eq $field.IsAutoIncrment true}}
					{{$field.GoColumnName}}:0,
				{{- else }}
    				{{$field.GoColumnName}}:req.Get{{$field.GoColumnName}}(),
				{{- end}}
			{{- else}}
				{{- if eq .IsDefaultCurrentTimestamp true}}	
					{{$field.GoColumnName}}:time.Now(),
				{{- end}}
			{{- end}}  
		{{- end}}  
	}
	var err error
	{{- range $index,$field := .Fields }}
			{{- if eq .GoColumnType  "time.Time"}}
				{{- if eq .IsDefaultCurrentTimestamp false}}
					{{- if eq $field.DataType "date"}}
						if a.{{$field.GoColumnName}}, err = time.ParseInLocation("2006-01-02", req.Get{{$field.GoColumnName}}(), time.Local); err != nil {
							return nil, err
						}
					{{- else }}
						if a.{{$field.GoColumnName}}, err = time.ParseInLocation("2006-01-02 15:04:05", req.Get{{$field.GoColumnName}}(), time.Local); err != nil {
							return nil, err
						}
					{{- end}}
				{{- end}}
			{{- end}}  
	{{- end}}  
	_, err = s.Client.{{.GoTableName}}.
		Create().
		Set{{.GoTableName}}(a).
		Save(ctx)
	if err != nil {
		return nil, err
	}
	// query after create and return
	a2, err := s.Client.Master.{{.GoTableName}}.
		Find().
		Where(
			{{.PackageName}}.{{.PrimaryKey.GoColumnName}}EQ(a.{{.PrimaryKey.GoColumnName}}),
		).
		One(ctx)
	if err != nil {
		return nil, err
	}
	return convert{{.GoTableName}}(a2), nil
}

// Delete{{.GoTableName}} Delete{{.GoTableName}}
func (s *{{.GoTableName}}ServiceImpl) Deletes{{.GoTableName}}(ctx context.Context, req *api.{{.GoTableName}}{{.PrimaryKey.GoColumnName}}) (*emptypb.Empty, error) {
	_, err := s.Client.{{.GoTableName}}.
		Delete().
		Where(
			{{.PackageName}}.{{.PrimaryKey.GoColumnName}}EQ(req.Get{{.PrimaryKey.GoColumnName}}()),
		).
		Exec(ctx)
	if err != nil {
		return nil, err
	}
	return &emptypb.Empty{}, nil
}

// Update{{.PackageName}} Update{{.GoTableName}}
func (s *{{.GoTableName}}ServiceImpl) Update{{.GoTableName}}(ctx context.Context, req *api.Update{{.GoTableName}}Req) (*api.{{.GoTableName}}, error) {

	if len(req.GetUpdateMask()) == 0 {
		return nil, errors.New("update_mask empty")
	}
	update := s.Client.{{.GoTableName}}.Update()
	for _, v := range req.GetUpdateMask() {
		switch v {	
		{{- range $index,$field := .Fields }}
		
			{{- if eq $field.IsPrimaryKey false}}
				case "{{$pkgName}}.{{$field.ColumnName}}":
				{{- if eq .GoColumnType  "time.Time"}}
					{{- if eq $field.DataType "date" }}
						t, err := time.ParseInLocation("2006-01-02", req.Get{{$tableName}}().Get{{$field.GoColumnName}}(), time.Local)
						if err != nil {
							return nil, err
						}
						update.Set{{$field.GoColumnName}}(t)
					{{- else }}
						t, err := time.ParseInLocation("2006-01-02 15:04:05", req.Get{{$tableName}}().Get{{$field.GoColumnName}}(), time.Local)
						if err != nil {
							return nil, err
						}
						update.Set{{$field.GoColumnName}}(t)
					{{- end }}
				{{- else}}
				update.Set{{$field.GoColumnName}}(req.Get{{$tableName}}().Get{{$field.GoColumnName}}())	
				{{- end}}
			
			{{- end}}
		{{- end}}  
		}
	}
	_, err := update.
		Where(
			{{.PackageName}}.{{.PrimaryKey.GoColumnName}}EQ(req.Get{{.GoTableName}}().Get{{.PrimaryKey.GoColumnName}}()),
		).
		Save(ctx)
	if err != nil {
		return nil, err
	}
	// query after update and return
	a, err := s.Client.Master.{{.GoTableName}}.
		Find().
		Where(
			{{.PackageName}}.{{.PrimaryKey.GoColumnName}}EQ(req.Get{{.GoTableName}}().Get{{.PrimaryKey.GoColumnName}}()),
		).
		One(ctx)
	if err != nil {
		return nil, err
	}
	return convert{{.GoTableName}}(a), nil
}

// Get{{.GoTableName}} Get{{.GoTableName}}
func (s *{{.GoTableName}}ServiceImpl) Get{{.GoTableName}}(ctx context.Context, req *api.{{.GoTableName}}{{.PrimaryKey.GoColumnName}}) (*api.{{.GoTableName}}, error) {
	a, err := s.Client.{{.GoTableName}}.
		Find().
		Where(
			{{.PackageName}}.{{.PrimaryKey.GoColumnName}}EQ(req.Get{{.PrimaryKey.GoColumnName}}()),
		).
		One(ctx)
	if err != nil {
		return nil, err
	}
	return convert{{.GoTableName}}(a), nil
}

// List{{.GoTableName}}s List{{.GoTableName}}s
func (s *{{.GoTableName}}ServiceImpl) List{{.GoTableName}}s(ctx context.Context, req *api.List{{.GoTableName}}sReq) (*api.List{{.GoTableName}}sResp, error) {
	page := req.GetPage()
	size := req.GetPageSize()
	if size <= 0 {
		size = 20
	}
	offset := size * (page - 1)
	if offset < 0 {
		offset = 0
	}
	finder := s.Client.{{.GoTableName}}.
		Find().
		Offset(offset).
		Limit(size)

	if req.GetOrderby() != "" {
		odb := strings.TrimPrefix(req.GetOrderby(), "-")
		if odb == req.GetOrderby() {
			finder.OrderAsc(odb)
		} else {
			finder.OrderDesc(odb)
		}
	}
	counter := s.Client.{{.GoTableName}}.
		Find().
		Count()

	var ps []*xsql.Predicate
	for _, v := range req.GetFilter() {
		p, err := xsql.GenP(v.Field, v.Op, v.Value)
		if err != nil {
			return nil, err
		}
		ps = append(ps, p)
	}

	list, err := finder.WhereP(ps...).All(ctx)
	if err != nil {
		return nil, err
	}

	count, err := counter.WhereP(ps...).Int64(ctx)
	if err != nil {
		return nil, err
	}
	pageCount := int64(math.Ceil(float64(count) / float64(size)))

	return &api.List{{.GoTableName}}sResp{ {{.GoTableName}}s: convert{{.GoTableName}}List(list), TotalCount: count, PageCount: pageCount}, nil
}

func convert{{.GoTableName}}(a *{{.PackageName}}.{{.GoTableName}}) *api.{{.GoTableName}} {
	return &api.{{.GoTableName}}{
		{{- range $index,$field := .Fields }}
		{{- if eq .GoColumnType  "time.Time"}}
			{{- if eq .DataType "date"}}
			{{$field.GoColumnName}}:a.{{$field.GoColumnName}}.Format("2006-01-02"),
			{{- else}}
			{{$field.GoColumnName}}:a.{{$field.GoColumnName}}.Format("2006-01-02 15:04:05"),
			{{- end}} 
		{{- else}}
			{{$field.GoColumnName}}:a.{{$field.GoColumnName}},
		{{- end}}	
		{{- end}}  
	}
}

func convert{{.GoTableName}}List(list []*{{.PackageName}}.{{.GoTableName}}) []*api.{{.GoTableName}} {
	ret := make([]*api.{{.GoTableName}}, 0, len(list))
	for _, v := range list {
		ret = append(ret, convert{{.GoTableName}}(v))
	}
	return ret
}
